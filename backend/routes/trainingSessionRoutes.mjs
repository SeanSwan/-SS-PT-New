/**\n * Training Session Management Routes\n * ================================\n * Routes for managing training sessions in client/admin/trainer dashboards\n * Integrates SwanStudios Store purchases with session management\n */\n\nimport express from 'express';\nimport { protect } from '../middleware/authMiddleware.mjs';\nimport TrainingSessionService from '../services/TrainingSessionService.mjs';\nimport Session from '../models/Session.mjs';\nimport User from '../models/User.mjs';\nimport logger from '../utils/logger.mjs';\n\nconst router = express.Router();\n\n/**\n * GET /api/training-sessions\n * Get training sessions for the authenticated user\n * Filters based on user role (client sees their sessions, trainer sees assigned sessions)\n */\nrouter.get('/', protect, async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const userRole = req.user.role;\n    const { status, limit = 50, offset = 0 } = req.query;\n\n    let whereClause = {};\n    let include = [];\n\n    // Filter based on user role\n    if (userRole === 'client') {\n      // Clients see their own sessions\n      whereClause.userId = userId;\n      include.push({\n        model: User,\n        as: 'trainer',\n        attributes: ['id', 'firstName', 'lastName', 'email'],\n        required: false\n      });\n    } else if (userRole === 'trainer') {\n      // Trainers see sessions assigned to them\n      whereClause.trainerId = userId;\n      include.push({\n        model: User,\n        as: 'client',\n        attributes: ['id', 'firstName', 'lastName', 'email'],\n        required: true\n      });\n    } else if (userRole === 'admin') {\n      // Admins see all sessions\n      include.push(\n        {\n          model: User,\n          as: 'client',\n          attributes: ['id', 'firstName', 'lastName', 'email'],\n          required: false\n        },\n        {\n          model: User,\n          as: 'trainer',\n          attributes: ['id', 'firstName', 'lastName', 'email'],\n          required: false\n        }\n      );\n    } else {\n      return res.status(403).json({\n        success: false,\n        message: 'Access denied'\n      });\n    }\n\n    // Add status filter if provided\n    if (status) {\n      whereClause.status = status;\n    }\n\n    const sessions = await Session.findAll({\n      where: whereClause,\n      include,\n      order: [['sessionDate', 'DESC']],\n      limit: parseInt(limit),\n      offset: parseInt(offset)\n    });\n\n    return res.status(200).json({\n      success: true,\n      sessions,\n      count: sessions.length\n    });\n  } catch (error) {\n    logger.error(`Error fetching training sessions:`, error);\n    return res.status(500).json({\n      success: false,\n      message: 'An error occurred while fetching training sessions'\n    });\n  }\n});\n\n/**\n * GET /api/training-sessions/summary\n * Get session summary for dashboard display\n */\nrouter.get('/summary', protect, async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const userRole = req.user.role;\n\n    let summary;\n\n    if (userRole === 'client') {\n      // Get summary for the client\n      summary = await TrainingSessionService.getSessionSummaryForUser(userId);\n    } else if (userRole === 'trainer') {\n      // Get summary for sessions assigned to this trainer\n      const sessionCounts = await Session.findAll({\n        where: { trainerId: userId },\n        attributes: [\n          'status',\n          [Session.sequelize.fn('COUNT', Session.sequelize.col('id')), 'count']\n        ],\n        group: ['status'],\n        raw: true\n      });\n\n      summary = {\n        available: 0,\n        scheduled: 0,\n        completed: 0,\n        cancelled: 0,\n        total: 0\n      };\n\n      sessionCounts.forEach(row => {\n        const status = row.status;\n        const count = parseInt(row.count);\n        \n        if (summary.hasOwnProperty(status)) {\n          summary[status] = count;\n        }\n        summary.total += count;\n      });\n    } else if (userRole === 'admin') {\n      // Get overall summary for admin\n      const sessionCounts = await Session.findAll({\n        attributes: [\n          'status',\n          [Session.sequelize.fn('COUNT', Session.sequelize.col('id')), 'count']\n        ],\n        group: ['status'],\n        raw: true\n      });\n\n      summary = {\n        available: 0,\n        scheduled: 0,\n        completed: 0,\n        cancelled: 0,\n        total: 0\n      };\n\n      sessionCounts.forEach(row => {\n        const status = row.status;\n        const count = parseInt(row.count);\n        \n        if (summary.hasOwnProperty(status)) {\n          summary[status] = count;\n        }\n        summary.total += count;\n      });\n    }\n\n    return res.status(200).json({\n      success: true,\n      summary\n    });\n  } catch (error) {\n    logger.error(`Error fetching session summary:`, error);\n    return res.status(500).json({\n      success: false,\n      message: 'An error occurred while fetching session summary'\n    });\n  }\n});\n\n/**\n * GET /api/training-sessions/available/:clientId\n * Get available sessions for a specific client (admin/trainer only)\n */\nrouter.get('/available/:clientId', protect, async (req, res) => {\n  try {\n    const userRole = req.user.role;\n    const clientId = req.params.clientId;\n\n    // Only admins and trainers can view other users' sessions\n    if (userRole !== 'admin' && userRole !== 'trainer') {\n      return res.status(403).json({\n        success: false,\n        message: 'Access denied'\n      });\n    }\n\n    const sessions = await TrainingSessionService.getAvailableSessionsForUser(parseInt(clientId));\n\n    return res.status(200).json({\n      success: true,\n      sessions,\n      count: sessions.length\n    });\n  } catch (error) {\n    logger.error(`Error fetching available sessions:`, error);\n    return res.status(500).json({\n      success: false,\n      message: 'An error occurred while fetching available sessions'\n    });\n  }\n});\n\n/**\n * POST /api/training-sessions/assign-trainer\n * Assign a trainer to available sessions (admin only)\n */\nrouter.post('/assign-trainer', protect, async (req, res) => {\n  try {\n    // Only admins can assign trainers\n    if (req.user.role !== 'admin') {\n      return res.status(403).json({\n        success: false,\n        message: 'Only administrators can assign trainers'\n      });\n    }\n\n    const { clientId, trainerId, sessionCount } = req.body;\n\n    if (!clientId || !trainerId) {\n      return res.status(400).json({\n        success: false,\n        message: 'Client ID and Trainer ID are required'\n      });\n    }\n\n    const result = await TrainingSessionService.assignTrainerToSessions(\n      parseInt(clientId),\n      parseInt(trainerId),\n      sessionCount ? parseInt(sessionCount) : null\n    );\n\n    return res.status(200).json({\n      success: true,\n      message: `Successfully assigned ${result.trainerName} to ${result.assignedCount} sessions`,\n      result\n    });\n  } catch (error) {\n    logger.error(`Error assigning trainer:`, error);\n    return res.status(500).json({\n      success: false,\n      message: error.message || 'An error occurred while assigning trainer'\n    });\n  }\n});\n\n/**\n * PUT /api/training-sessions/:id/schedule\n * Schedule a specific session (admin/trainer only)\n */\nrouter.put('/:id/schedule', protect, async (req, res) => {\n  try {\n    const userRole = req.user.role;\n    const sessionId = req.params.id;\n    const { sessionDate, location, duration, notes } = req.body;\n\n    // Only admins and trainers can schedule sessions\n    if (userRole !== 'admin' && userRole !== 'trainer') {\n      return res.status(403).json({\n        success: false,\n        message: 'Access denied'\n      });\n    }\n\n    const session = await Session.findByPk(sessionId);\n\n    if (!session) {\n      return res.status(404).json({\n        success: false,\n        message: 'Session not found'\n      });\n    }\n\n    // If user is a trainer, they can only schedule their own assigned sessions\n    if (userRole === 'trainer' && session.trainerId !== req.user.id) {\n      return res.status(403).json({\n        success: false,\n        message: 'You can only schedule sessions assigned to you'\n      });\n    }\n\n    // Update session with scheduling information\n    if (sessionDate) session.sessionDate = new Date(sessionDate);\n    if (location) session.location = location;\n    if (duration) session.duration = parseInt(duration);\n    if (notes) session.notes = notes;\n    session.status = 'scheduled';\n\n    await session.save();\n\n    // Fetch updated session with related data\n    const updatedSession = await Session.findByPk(sessionId, {\n      include: [\n        {\n          model: User,\n          as: 'client',\n          attributes: ['id', 'firstName', 'lastName', 'email']\n        },\n        {\n          model: User,\n          as: 'trainer',\n          attributes: ['id', 'firstName', 'lastName', 'email']\n        }\n      ]\n    });\n\n    return res.status(200).json({\n      success: true,\n      message: 'Session scheduled successfully',\n      session: updatedSession\n    });\n  } catch (error) {\n    logger.error(`Error scheduling session:`, error);\n    return res.status(500).json({\n      success: false,\n      message: 'An error occurred while scheduling the session'\n    });\n  }\n});\n\n/**\n * PUT /api/training-sessions/:id/complete\n * Mark a session as completed (trainer/admin only)\n */\nrouter.put('/:id/complete', protect, async (req, res) => {\n  try {\n    const userRole = req.user.role;\n    const sessionId = req.params.id;\n    const { notes, rating, feedback } = req.body;\n\n    // Only admins and trainers can complete sessions\n    if (userRole !== 'admin' && userRole !== 'trainer') {\n      return res.status(403).json({\n        success: false,\n        message: 'Access denied'\n      });\n    }\n\n    const session = await Session.findByPk(sessionId);\n\n    if (!session) {\n      return res.status(404).json({\n        success: false,\n        message: 'Session not found'\n      });\n    }\n\n    // If user is a trainer, they can only complete their own assigned sessions\n    if (userRole === 'trainer' && session.trainerId !== req.user.id) {\n      return res.status(403).json({\n        success: false,\n        message: 'You can only complete sessions assigned to you'\n      });\n    }\n\n    // Update session as completed\n    session.status = 'completed';\n    session.sessionDeducted = true;\n    session.deductionDate = new Date();\n    if (notes) session.notes = notes;\n    if (rating) session.rating = parseInt(rating);\n    if (feedback) {\n      session.feedback = feedback;\n      session.feedbackProvided = true;\n    }\n\n    await session.save();\n\n    return res.status(200).json({\n      success: true,\n      message: 'Session marked as completed',\n      session\n    });\n  } catch (error) {\n    logger.error(`Error completing session:`, error);\n    return res.status(500).json({\n      success: false,\n      message: 'An error occurred while completing the session'\n    });\n  }\n});\n\nexport default router;\n