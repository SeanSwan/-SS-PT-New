import express from 'express';
import sequelize from '../database.mjs';
import logger from '../utils/logger.mjs';
import { getMongoDBStatus } from '../mongodb-connect.mjs';
import { mcpHealthManager } from '../utils/monitoring/mcpHealthManager.mjs';
import { piiSafeLogger } from '../utils/monitoring/piiSafeLogging.mjs';
import os from 'os';
import { version } from 'process';

const router = express.Router();

/**
 * @route   GET /api/health
 * @desc    Enhanced health check with MCP monitoring and P0 security
 * @access  Public
 */
router.get('/', async (req, res) => {
  try {
    // Check PostgreSQL database connection
    let postgresConnected = false;
    let postgresError = null;
    try {
      await sequelize.authenticate();
      postgresConnected = true;
    } catch (dbError) {
      postgresError = dbError.message;
      logger.error('PostgreSQL health check failed:', { error: dbError.message });
    }
    
    // Get MongoDB status
    const mongoStatus = getMongoDBStatus();
    
    // Get MCP ecosystem health
    let mcpHealth = { overallHealth: 0, healthyServers: 0, totalServers: 0, error: null };
    try {
      mcpHealth = await mcpHealthManager.getMCPEcosystemHealth();
    } catch (mcpError) {
      mcpHealth.error = mcpError.message;
      piiSafeLogger.error('MCP health check failed', { error: mcpError.message });
    }
    
    // Get system information
    const systemInfo = {
      platform: os.platform(),
      arch: os.arch(),
      cpus: os.cpus().length,
      totalMem: Math.round(os.totalmem() / (1024 * 1024)) + 'MB',
      freeMem: Math.round(os.freemem() / (1024 * 1024)) + 'MB',
      nodeVersion: version,
      uptime: formatUptime(process.uptime())
    };\n    \n    // Determine overall health status\n    const isProduction = process.env.NODE_ENV === 'production';\n    const dbHealthy = isProduction \n      ? (postgresConnected && mongoStatus.connected)\n      : (postgresConnected || mongoStatus.connected);\n    const mcpHealthy = mcpHealth.overallHealth >= 60; // At least 60% of MCP servers healthy\n    const isHealthy = dbHealthy && mcpHealthy;\n    \n    // Build comprehensive health response\n    const healthResponse = {\n      success: isHealthy,\n      status: isHealthy ? 'healthy' : 'degraded',\n      message: isHealthy ? 'All systems operational' : 'Some systems experiencing issues',\n      environment: process.env.NODE_ENV || 'development',\n      timestamp: new Date().toISOString(),\n      \n      // Database health\n      databases: {\n        postgres: {\n          connected: postgresConnected,\n          type: 'primary',\n          ...(postgresError && { error: postgresError })\n        },\n        mongodb: {\n          connected: mongoStatus.connected,\n          usingSQLite: mongoStatus.usingSQLite || false,\n          type: 'workout/gamification'\n        }\n      },\n      \n      // MCP health\n      mcp: {\n        status: mcpHealthy ? 'healthy' : 'degraded',\n        overallHealth: `${Math.round(mcpHealth.overallHealth)}%`,\n        healthyServers: `${mcpHealth.healthyServers}/${mcpHealth.totalServers}`,\n        averageLatency: `${Math.round(mcpHealth.averageLatency || 0)}ms`,\n        ...(mcpHealth.error && { error: mcpHealth.error })\n      },\n      \n      // System information\n      system: systemInfo,\n      \n      // Monitoring systems\n      monitoring: {\n        piiSafeLogging: 'enabled',\n        mcpHealthManager: 'enabled',\n        accessibilityAuth: 'enabled'\n      },\n      \n      // Uptime details\n      uptime: {\n        seconds: Math.floor(process.uptime()),\n        formatted: formatUptime(process.uptime())\n      }\n    };\n    \n    // Log health check access with PII safety\n    piiSafeLogger.trackUserAction('health_check', req.user?.id || 'anonymous', {\n      timestamp: new Date().toISOString(),\n      healthy: isHealthy\n    });\n    \n    res.status(isHealthy ? 200 : 503).json(healthResponse);\n  } catch (error) {\n    logger.error('Health check failed:', { error: error.message });\n    piiSafeLogger.error('Health check system error', { error: error.message });\n    \n    res.status(500).json({\n      success: false,\n      status: 'error',\n      message: 'Health check system error',\n      error: error.message,\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime()\n    });\n  }\n});\n\n/**\n * @route   GET /api/health/detailed\n * @desc    Detailed system diagnostics with PII-safe logging\n * @access  Private (logged users)\n */\nrouter.get('/detailed', async (req, res) => {\n  try {\n    const diagnostics = {\n      timestamp: new Date().toISOString(),\n      \n      // System details\n      system: {\n        platform: process.platform,\n        version: process.version,\n        architecture: process.arch,\n        cpuUsage: process.cpuUsage(),\n        memoryUsage: process.memoryUsage(),\n        uptime: process.uptime(),\n        loadAverage: os.loadavg()\n      },\n      \n      // Environment details\n      environment: {\n        nodeEnv: process.env.NODE_ENV,\n        port: process.env.PORT,\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone\n      },\n      \n      // Database diagnostics\n      database: {\n        postgres: { status: 'unknown' },\n        mongodb: { status: 'unknown' }\n      },\n      \n      // MCP diagnostics\n      mcp: {\n        status: 'unknown',\n        servers: {}\n      },\n      \n      // Monitoring systems\n      monitoring: {\n        piiSafeLogging: 'enabled',\n        mcpHealthManager: 'enabled',\n        accessibilityAuth: 'enabled',\n        gamificationTracking: 'enabled',\n        aiGenerationMonitoring: 'enabled'\n      }\n    };\n\n    // PostgreSQL detailed diagnostics\n    try {\n      const startTime = Date.now();\n      await sequelize.authenticate();\n      const connectionTime = Date.now() - startTime;\n      \n      diagnostics.database.postgres = {\n        status: 'connected',\n        connectionTime: `${connectionTime}ms`,\n        dialect: sequelize.getDialect(),\n        version: await sequelize.databaseVersion(),\n        poolSize: sequelize.connectionManager.pool?.size || 'N/A'\n      };\n    } catch (error) {\n      diagnostics.database.postgres = {\n        status: 'error',\n        error: error.message\n      };\n    }\n\n    // MongoDB detailed diagnostics\n    try {\n      const mongoStatus = getMongoDBStatus();\n      diagnostics.database.mongodb = {\n        status: mongoStatus.connected ? 'connected' : 'disconnected',\n        database: mongoStatus.database,\n        lastConnectionAttempt: mongoStatus.lastConnectionAttempt,\n        usingSQLite: mongoStatus.usingSQLite\n      };\n    } catch (error) {\n      diagnostics.database.mongodb = {\n        status: 'error',\n        error: error.message\n      };\n    }\n\n    // MCP detailed diagnostics\n    try {\n      const mcpReport = await mcpHealthManager.generateHealthReport();\n      diagnostics.mcp = {\n        status: 'analyzed',\n        summary: mcpReport.summary,\n        servers: mcpReport.servers,\n        lastUpdated: mcpReport.timestamp\n      };\n    } catch (error) {\n      diagnostics.mcp = {\n        status: 'error',\n        error: error.message\n      };\n    }\n\n    // Log detailed health check access\n    piiSafeLogger.trackUserAction('health_check_detailed', req.user?.id || 'anonymous', {\n      timestamp: new Date().toISOString()\n    });\n\n    res.json({\n      success: true,\n      data: diagnostics\n    });\n  } catch (error) {\n    logger.error('Detailed health check failed:', { error: error.message });\n    piiSafeLogger.error('Detailed health check error', { error: error.message });\n    \n    res.status(500).json({\n      success: false,\n      message: 'Detailed health check failed',\n      error: error.message,\n      timestamp: new Date().toISOString()\n    });\n  }\n});\n\n/**\n * @route   GET /api/health/database\n * @desc    Database connectivity check with enhanced diagnostics\n * @access  Public\n */\nrouter.get('/database', async (req, res) => {\n  try {\n    // Test PostgreSQL connection\n    await sequelize.authenticate();\n    \n    // Get database information\n    const [results] = await sequelize.query('SELECT version();');\n    const dbVersion = results[0]?.version || 'Unknown';\n    \n    // Get MongoDB status\n    const mongoStatus = getMongoDBStatus();\n    \n    const databaseHealth = {\n      success: true,\n      message: 'Database connections successful',\n      timestamp: new Date().toISOString(),\n      postgres: {\n        connected: true,\n        version: dbVersion,\n        dialect: sequelize.getDialect()\n      },\n      mongodb: {\n        connected: mongoStatus.connected,\n        database: mongoStatus.database,\n        usingSQLite: mongoStatus.usingSQLite\n      }\n    };\n    \n    // Log database health check\n    piiSafeLogger.trackUserAction('database_health_check', req.user?.id || 'anonymous', {\n      postgresConnected: true,\n      mongodbConnected: mongoStatus.connected\n    });\n    \n    res.status(200).json(databaseHealth);\n  } catch (error) {\n    logger.error('Database health check failed:', { error: error.message, stack: error.stack });\n    piiSafeLogger.error('Database health check failed', { error: error.message });\n    \n    res.status(500).json({\n      success: false,\n      message: 'Database connection failed',\n      error: error.message,\n      timestamp: new Date().toISOString()\n    });\n  }\n});\n\n/**\n * @route   GET /api/health/mcp\n * @desc    MCP ecosystem health check\n * @access  Public\n */\nrouter.get('/mcp', async (req, res) => {\n  try {\n    const mcpHealth = await mcpHealthManager.getMCPEcosystemHealth();\n    \n    // Log MCP health check\n    piiSafeLogger.trackMCPOperation('health_system', 'ecosystem_check', {\n      overallHealth: mcpHealth.overallHealth,\n      healthyServers: mcpHealth.healthyServers,\n      totalServers: mcpHealth.totalServers\n    });\n    \n    res.json({\n      success: true,\n      message: 'MCP ecosystem health retrieved',\n      data: mcpHealth,\n      timestamp: new Date().toISOString()\n    });\n  } catch (error) {\n    logger.error('MCP health check failed:', { error: error.message });\n    piiSafeLogger.error('MCP health check failed', { error: error.message });\n    \n    res.status(500).json({\n      success: false,\n      message: 'Failed to retrieve MCP health information',\n      error: error.message,\n      timestamp: new Date().toISOString()\n    });\n  }\n});\n\n/**\n * @route   GET /api/health/mcp/:serverName\n * @desc    Individual MCP server health check\n * @access  Public\n */\nrouter.get('/mcp/:serverName', async (req, res) => {\n  const { serverName } = req.params;\n  \n  try {\n    const serverHealth = await mcpHealthManager.checkSingleMCPHealth(serverName);\n    const serverMetrics = mcpHealthManager.getServerMetrics(serverName);\n    \n    // Log individual server health check\n    piiSafeLogger.trackMCPOperation(serverName, 'individual_health_check', {\n      healthy: serverHealth.healthy,\n      latency: serverHealth.latency\n    });\n    \n    res.json({\n      success: true,\n      message: `Health check for ${serverName} completed`,\n      data: {\n        server: serverName,\n        health: serverHealth,\n        metrics: serverMetrics\n      },\n      timestamp: new Date().toISOString()\n    });\n  } catch (error) {\n    logger.error(`MCP server ${serverName} health check failed:`, { error: error.message });\n    piiSafeLogger.trackMCPOperation(serverName, 'health_check_failed', {\n      error: error.message\n    });\n    \n    res.status(404).json({\n      success: false,\n      message: `MCP server '${serverName}' not found or unreachable`,\n      error: error.message,\n      timestamp: new Date().toISOString()\n    });\n  }\n});\n\n/**\n * @route   GET /api/health/accessibility\n * @desc    Accessibility health check and feature status\n * @access  Public\n */\nrouter.get('/accessibility', async (req, res) => {\n  const accessibilityHealth = {\n    success: true,\n    status: 'healthy',\n    message: 'All accessibility features operational',\n    features: {\n      screenReaderSupport: 'enabled',\n      keyboardNavigation: 'enabled',\n      highContrastMode: 'enabled',\n      reducedMotion: 'enabled',\n      largeTextSupport: 'enabled',\n      voiceControl: 'enabled',\n      piiSafeLogging: 'enabled'\n    },\n    compliance: {\n      wcagLevel: 'AA',\n      standards: ['508 Compliance', 'ADA Compliance']\n    },\n    monitoring: {\n      usageTracking: 'enabled',\n      errorReporting: 'enabled',\n      accessibilityAuth: 'enabled'\n    },\n    timestamp: new Date().toISOString()\n  };\n  \n  // Log accessibility health check\n  piiSafeLogger.trackAccessibilityUsage('health_check', req.user?.id || 'anonymous', {\n    timestamp: new Date().toISOString()\n  });\n  \n  res.json(accessibilityHealth);\n});\n\n/**\n * Format uptime in human-readable format\n * @param {number} uptime - Uptime in seconds\n * @returns {string} Formatted uptime string\n */\nfunction formatUptime(uptime) {\n  const days = Math.floor(uptime / 86400);\n  const hours = Math.floor((uptime % 86400) / 3600);\n  const minutes = Math.floor((uptime % 3600) / 60);\n  const seconds = Math.floor(uptime % 60);\n  \n  let formatted = '';\n  if (days > 0) formatted += `${days}d `;\n  if (hours > 0 || days > 0) formatted += `${hours}h `;\n  if (minutes > 0 || hours > 0 || days > 0) formatted += `${minutes}m `;\n  formatted += `${seconds}s`;\n  \n  return formatted;\n}\n\nexport default router;