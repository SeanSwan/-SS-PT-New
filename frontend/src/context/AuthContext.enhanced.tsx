/**
 * Enhanced AuthContext with Better Role Handling
 * ==============================================
 * This version adds extensive logging and ensures role is properly handled
 */

import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport apiService from '../services/api.service';\nimport { setUser as setReduxUser, logout as logoutRedux, setLoading as setReduxLoading } from '../store/slices/authSlice';\nimport { createClientProgressService, ClientProgressServiceInterface } from '../services/client-progress-service';\nimport { createExerciseService, ExerciseServiceInterface } from '../services/exercise-service';\nimport { createAdminClientService, AdminClientServiceInterface } from '../services/adminClientService';\nimport { useBackendConnection } from '../hooks/useBackendConnection.jsx';\nimport { AxiosInstance } from 'axios';\nimport tokenCleanup from '../utils/tokenCleanup';\n\n// Enhanced User Interface aligned with backend model\nexport interface User {\n  id: string;\n  email: string;\n  username: string;\n  firstName: string;\n  lastName: string;\n  role: 'admin' | 'trainer' | 'client' | 'user';\n  profileImageUrl?: string;\n  isActive: boolean;\n  createdAt: string;\n  updatedAt: string;\n  trainerInfo?: any;\n  clientInfo?: any;\n}\n\n// Auth Context Interface\ninterface AuthContextType {\n  user: User | null;\n  isAuthenticated: boolean;\n  loading: boolean;\n  error: string | null;\n  login: (username: string, password: string) => Promise<{success: boolean, user: User | null, error?: string}>;\n  logout: () => void;\n  register: (data: any) => Promise<{success: boolean, user: User | null, error?: string}>;\n  updateUser: (data: any) => Promise<{success: boolean, user: User | null, error?: string}>;\n  refreshToken: () => Promise<boolean>;\n  checkPermission: (permission: string) => boolean;\n  services: {\n    clientProgress: ClientProgressServiceInterface;\n    exercise: ExerciseServiceInterface;\n    adminClient: AdminClientServiceInterface;\n  };\n  authAxios: AxiosInstance;\n}\n\n// Create the Auth Context\nconst AuthContext = createContext<AuthContextType>({\n  user: null,\n  isAuthenticated: false,\n  loading: true,\n  error: null,\n  login: async () => ({ success: false, user: null }),\n  logout: () => {},\n  register: async () => ({ success: false, user: null }),\n  updateUser: async () => ({ success: false, user: null }),\n  refreshToken: async () => false,\n  checkPermission: () => false,\n  services: {\n    clientProgress: null as any,\n    exercise: null as any,\n    adminClient: null as any\n  },\n  authAxios: null as any\n});\n\n// Permission mappings for roles\nconst ROLE_PERMISSIONS = {\n  admin: ['admin:all', 'trainer:all', 'client:all', 'user:all'],\n  trainer: ['trainer:all', 'client:read', 'client:update'],\n  client: ['client:self'],\n  user: ['user:self']\n};\n\n// Enhanced user validation and formatting\nconst validateAndFormatUser = (userData: any, source: string): User => {\n  console.log(`üîç [AuthContext] Validating user from ${source}:`, userData);\n  \n  // Ensure required fields exist\n  if (!userData || !userData.id) {\n    throw new Error(`Invalid user data from ${source}: missing ID`);\n  }\n  \n  // Extract and validate role\n  let role = userData.role || 'user';\n  console.log(`üè∑Ô∏è [AuthContext] Original role from ${source}:`, { raw: role, type: typeof role });\n  \n  // Ensure role is valid\n  const validRoles = ['admin', 'trainer', 'client', 'user'];\n  if (!validRoles.includes(role)) {\n    console.warn(`‚ö†Ô∏è [AuthContext] Invalid role \"${role}\" from ${source}, defaulting to 'user'`);\n    role = 'user';\n  }\n  \n  const formattedUser: User = {\n    id: String(userData.id),\n    email: userData.email || '',\n    username: userData.username || userData.email?.split('@')[0] || 'unknown',\n    firstName: userData.firstName || '',\n    lastName: userData.lastName || '',\n    role: role as User['role'],\n    profileImageUrl: userData.profileImageUrl || userData.profileImage || userData.photo,\n    isActive: userData.isActive !== false,\n    createdAt: userData.createdAt || new Date().toISOString(),\n    updatedAt: userData.updatedAt || new Date().toISOString(),\n    trainerInfo: userData.trainerInfo,\n    clientInfo: userData.clientInfo\n  };\n  \n  console.log(`‚úÖ [AuthContext] Formatted user for ${source}:`, {\n    id: formattedUser.id,\n    username: formattedUser.username,\n    role: formattedUser.role,\n    roleType: typeof formattedUser.role\n  });\n  \n  return formattedUser;\n};\n\n// Auth Provider Component\nexport const AuthProvider: React.FC<{children: React.ReactNode}> = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  \n  // Backend connection state\n  const connection = useBackendConnection();\n  \n  // Redux integration (optional)\n  let dispatch: any = null;\n  let reduxUser: any = null;\n  \n  try {\n    dispatch = useDispatch();\n    reduxUser = useSelector((state: any) => state.auth?.user);\n  } catch (error) {\n    console.log('Redux not available, using local state only');\n  }\n  \n  // Create services with authenticated axios instance\n  const services = {\n    clientProgress: createClientProgressService(apiService),\n    exercise: createExerciseService(apiService),\n    adminClient: createAdminClientService(apiService)\n  };\n  \n  // Enhanced setUser function with logging\n  const setUserWithLogging = useCallback((userData: User | null, source: string) => {\n    console.log(`üîÑ [AuthContext] Setting user from ${source}:`, {\n      userData: userData ? {\n        id: userData.id,\n        username: userData.username,\n        role: userData.role,\n        roleType: typeof userData.role\n      } : null\n    });\n    \n    setUser(userData);\n    \n    // Update Redux if available\n    if (dispatch && userData) {\n      console.log(`üìã [AuthContext] Updating Redux with user role: ${userData.role}`);\n      dispatch(setReduxUser(userData));\n    }\n  }, [dispatch]);\n  \n  // Token refresh function\n  const refreshToken = useCallback(async (): Promise<boolean> => {\n    try {\n      const token = tokenCleanup.getValidatedToken();\n      if (!token) return false;\n      \n      const response = await apiService.post('/api/auth/refresh', {}, {\n        headers: { Authorization: `Bearer ${token}` }\n      });\n      \n      if (response.data.token) {\n        const newToken = response.data.token;\n        tokenCleanup.storeToken(newToken);\n        apiService.setAuthToken(newToken);\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Token refresh failed:', error);\n      tokenCleanup.handleTokenError(error);\n      return false;\n    }\n  }, []);\n  \n  // Check if user has permission\n  const checkPermission = useCallback((permission: string): boolean => {\n    if (!user) return false;\n    \n    const userPermissions = ROLE_PERMISSIONS[user.role] || [];\n    return userPermissions.some(p => \n      p === permission || \n      p.endsWith(':all') && permission.startsWith(p.split(':')[0])\n    );\n  }, [user]);\n  \n  // Enhanced mock login function with better role detection\n  const performMockLogin = async (username: string, password: string): Promise<{success: boolean, user: User | null, error?: string}> => {\n    console.log(`üé≠ [AuthContext] Performing mock login for: ${username}`);\n    \n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    // Enhanced role detection\n    let role: User['role'] = 'user';\n    const lowerUsername = username.toLowerCase();\n    \n    // Check for exact username matches first\n    if (lowerUsername === 'admin') role = 'admin';\n    else if (lowerUsername === 'trainer') role = 'trainer';\n    else if (lowerUsername === 'client') role = 'client';\n    // Then check for contains\n    else if (lowerUsername.includes('admin')) role = 'admin';\n    else if (lowerUsername.includes('trainer')) role = 'trainer';\n    else if (lowerUsername.includes('client')) role = 'client';\n    \n    console.log(`üé≠ [AuthContext] Mock login role determination: ${username} -> ${role}`);\n    \n    const mockUser: User = {\n      id: `mock-${Date.now()}`,\n      email: username.includes('@') ? username : `${username}@example.com`,\n      username: username.includes('@') ? username.split('@')[0] : username,\n      firstName: 'Mock',\n      lastName: 'User',\n      role,\n      isActive: true,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n    \n    const mockToken = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${btoa(JSON.stringify({sub: mockUser.id, role: mockUser.role, iat: Math.floor(Date.now()/1000), exp: Math.floor(Date.now()/1000) + (24*60*60)}))}.mock-signature`;\n    tokenCleanup.storeToken(mockToken, mockUser);\n    apiService.setAuthToken(mockToken);\n    \n    setUserWithLogging(mockUser, 'mock login');\n    \n    console.log(`‚úÖ [AuthContext] Mock login successful:`, {\n      username: mockUser.username,\n      role: mockUser.role\n    });\n    \n    return { success: true, user: mockUser };\n  };\n  \n  // Check authentication status on mount\n  useEffect(() => {\n    const checkAuthStatus = async () => {\n      console.log(`üîç [AuthContext] Checking auth status...`);\n      setLoading(true);\n      setError(null);\n      \n      try {\n        // Get validated token from cleanup utility\n        const token = tokenCleanup.getValidatedToken();\n        const tokenTimestamp = localStorage.getItem('tokenTimestamp');\n        \n        if (!token) {\n          console.log('üîç [AuthContext] No valid token found');\n          setUserWithLogging(null, 'auth check - no token');\n          setLoading(false);\n          return;\n        }\n        \n        // Check token age (24 hours) - this is already done in getValidatedToken\n        // but keeping this check as a backup\n        if (tokenTimestamp) {\n          const age = Date.now() - parseInt(tokenTimestamp);\n          const maxAge = 24 * 60 * 60 * 1000; // 24 hours\n          \n          if (age > maxAge) {\n            console.log('üïê [AuthContext] Token expired, attempting refresh...');\n            const refreshed = await refreshToken();\n            \n            if (!refreshed) {\n              console.log('‚ùå [AuthContext] Token refresh failed, logging out');\n              logout();\n              return;\n            }\n          }\n        }\n        \n        // Set token in API service\n        apiService.setAuthToken(token);\n        \n        // Verify token with backend\n        console.log('üåê [AuthContext] Verifying token with backend...');\n        const response = await apiService.get('/api/auth/me');\n        \n        if (response.data?.user) {\n          const userData = response.data.user;\n          console.log('‚úÖ [AuthContext] Backend returned user:', {\n            id: userData.id,\n            username: userData.username,\n            role: userData.role,\n            roleType: typeof userData.role\n          });\n          \n          const formattedUser = validateAndFormatUser(userData, 'backend verification');\n          setUserWithLogging(formattedUser, 'auth check - backend verification');\n          \n          console.log('‚úÖ [AuthContext] Authentication restored');\n        } else {\n          throw new Error('Invalid user data from server');\n        }\n      } catch (error) {\n        console.error('‚ùå [AuthContext] Auth check failed:', error);\n        \n        // Try fallback to mock user for development\n        const storedUser = localStorage.getItem('user');\n        if (storedUser && process.env.NODE_ENV === 'development') {\n          try {\n            const userData = JSON.parse(storedUser);\n            console.log('üîÑ [AuthContext] Using fallback stored user:', userData);\n            const formattedUser = validateAndFormatUser(userData, 'stored user fallback');\n            setUserWithLogging(formattedUser, 'auth check - stored user fallback');\n          } catch (parseError) {\n            console.error('‚ùå [AuthContext] Failed to parse stored user data:', parseError);\n            logout();\n          }\n        } else {\n          setError('Authentication failed');\n          logout();\n        }\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    checkAuthStatus();\n  }, [logout, refreshToken, setUserWithLogging]);\n  \n  // Enhanced login function with extensive logging\n  const login = async (username: string, password: string): Promise<{success: boolean, user: User | null, error?: string}> => {\n    console.log(`üîê [AuthContext] Login attempt for: ${username}`);\n    setLoading(true);\n    setError(null);\n    \n    // If backend is not connected, use mock data only in development\n    if (!connection.isConnected && connection.isMockMode && process.env.NODE_ENV === 'development') {\n      console.log('üé≠ [AuthContext] Backend not available, using mock login');\n      const result = await performMockLogin(username, password);\n      setLoading(false);\n      return result;\n    }\n    \n    try {\n      // Attempt real API login\n      console.log('üåê [AuthContext] Attempting real API login...');\n      const response = await apiService.post('/api/auth/login', { \n        username, \n        password \n      });\n      \n      console.log('üì® [AuthContext] API login response:', {\n        status: response.status,\n        success: response.data?.success,\n        hasUser: !!response.data?.user,\n        hasToken: !!response.data?.token,\n        userRole: response.data?.user?.role\n      });\n      \n      if (response.data?.user && response.data?.token) {\n        const { user: userData, token } = response.data;\n        \n        console.log('‚úÖ [AuthContext] API returned user data:', {\n          id: userData.id,\n          username: userData.username,\n          role: userData.role,\n          roleType: typeof userData.role\n        });\n        \n        // Validate and format user data\n        const formattedUser = validateAndFormatUser(userData, 'API login response');\n        \n        // Store token and user using cleanup utility\n        tokenCleanup.storeToken(token, formattedUser);\n        apiService.setAuthToken(token);\n        \n        // Set user in state\n        setUserWithLogging(formattedUser, 'login - API response');\n        \n        console.log('‚úÖ [AuthContext] Login successful:', {\n          username: formattedUser.username,\n          role: formattedUser.role\n        });\n        \n        setLoading(false);\n        return { success: true, user: formattedUser };\n      } else {\n        throw new Error('Invalid login response - missing user or token');\n      }\n    } catch (error: any) {\n      console.error('‚ùå [AuthContext] API login failed:', error);\n      \n      // Development fallback - use mock login\n      if (process.env.NODE_ENV === 'development') {\n        console.log('üé≠ [AuthContext] API login failed, falling back to mock login');\n        const result = await performMockLogin(username, password);\n        setLoading(false);\n        return result;\n      }\n      \n      const errorMessage = error.response?.data?.message || error.message || 'Login failed';\n      setError(errorMessage);\n      setLoading(false);\n      return { success: false, user: null, error: errorMessage };\n    }\n  };\n  \n  // Enhanced logout function\n  const logout = useCallback(() => {\n    console.log('üö™ [AuthContext] Logging out...');\n    \n    try {\n      // Call logout API if authenticated\n      const token = tokenCleanup.getValidatedToken();\n      if (token && !token.includes('mock-signature')) {\n        apiService.post('/api/auth/logout').catch(console.error);\n      }\n    } catch (error) {\n      console.error('‚ùå [AuthContext] Logout API error:', error);\n    }\n    \n    // Clear all stored data using cleanup utility\n    tokenCleanup.cleanupAllTokens();\n    \n    // Clear API auth\n    apiService.setAuthToken(null);\n    \n    // Update state\n    setUserWithLogging(null, 'logout');\n    setError(null);\n    \n    console.log('‚úÖ [AuthContext] Logged out successfully');\n  }, [setUserWithLogging]);\n  \n  // Register function (simplified for now)\n  const register = async (data: any): Promise<{success: boolean, user: User | null, error?: string}> => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const response = await apiService.post('/api/auth/register', data);\n      \n      if (response.data?.user && response.data?.token) {\n        const { user: userData, token } = response.data;\n        \n        // Store token\n        localStorage.setItem('token', token);\n        localStorage.setItem('tokenTimestamp', Date.now().toString());\n        apiService.setAuthToken(token);\n        \n        // Format user data\n        const formattedUser = validateAndFormatUser(userData, 'registration response');\n        \n        setUserWithLogging(formattedUser, 'register');\n        localStorage.setItem('user', JSON.stringify(formattedUser));\n        \n        console.log('Registration successful:', formattedUser.username);\n        return { success: true, user: formattedUser };\n      } else {\n        throw new Error('Invalid registration response');\n      }\n    } catch (error: any) {\n      console.error('Registration failed:', error);\n      const errorMessage = error.response?.data?.message || error.message || 'Registration failed';\n      setError(errorMessage);\n      return { success: false, user: null, error: errorMessage };\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  // Update user function (simplified for now)\n  const updateUser = async (data: any): Promise<{success: boolean, user: User | null, error?: string}> => {\n    if (!user) return { success: false, user: null, error: 'Not authenticated' };\n    \n    setLoading(true);\n    setError(null);\n    \n    try {\n      const response = await apiService.put('/api/auth/profile', data);\n      \n      if (response.data?.user) {\n        const userData = response.data.user;\n        \n        const updatedUser: User = {\n          ...user,\n          ...userData,\n          updatedAt: new Date().toISOString()\n        };\n        \n        setUserWithLogging(updatedUser, 'update user');\n        localStorage.setItem('user', JSON.stringify(updatedUser));\n        \n        console.log('User updated successfully');\n        return { success: true, user: updatedUser };\n      } else {\n        throw new Error('Invalid update response');\n      }\n    } catch (error: any) {\n      console.error('User update failed:', error);\n      const errorMessage = error.response?.data?.message || error.message || 'Update failed';\n      setError(errorMessage);\n      return { success: false, user: null, error: errorMessage };\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  // Context value\n  const contextValue: AuthContextType = {\n    user,\n    isAuthenticated: !!user,\n    loading,\n    error,\n    login,\n    logout,\n    register,\n    updateUser,\n    refreshToken,\n    checkPermission,\n    services,\n    authAxios: apiService\n  };\n  \n  // Log current state periodically in development\n  useEffect(() => {\n    if (process.env.NODE_ENV === 'development') {\n      console.log('üîÑ [AuthContext] Current state:', {\n        hasUser: !!user,\n        username: user?.username,\n        role: user?.role,\n        isAuthenticated: !!user,\n        loading\n      });\n    }\n  }, [user, loading]);\n  \n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// Custom hook for using the Auth Context\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\nexport default AuthContext;\n